{% include base_path %}

<!-- start custom head snippets -->

<!-- Support for Academicons -->
<link rel="stylesheet" href="{{ base_path }}/assets/css/academicons.css"/>

<script>
  document.documentElement.classList.add("js-enhanced");
</script>

<style>
  :root {
    --nav-link-text-color: #3f4b59;
    --nav-link-hover-color: #0f766e;
    --nav-link-active-color: #0f766e;
    --content-heading-color: #1f4e79;
    --content-subheading-color: #335c81;
  }

  html[data-theme="dark"] {
    --nav-link-text-color: #d5dde8;
    --nav-link-hover-color: #5eead4;
    --nav-link-active-color: #67e8f9;
    --content-heading-color: #93c5fd;
    --content-subheading-color: #bfdbfe;
  }

  html {
    scroll-behavior: auto;
  }

  .page__content h1,
  .page__content h2,
  .page__content h3,
  .page__content h4 {
    scroll-margin-top: calc(var(--masthead-offset, 70px) + 0.75rem);
  }

  .page__content h2 {
    color: var(--content-heading-color);
  }

  .page__content h3 {
    color: var(--content-subheading-color);
  }

  .author__map-widget {
    margin-top: 1rem;
    white-space: normal;
    cursor: default;
  }

  .author__map-widget .author__map-widget-inner {
    width: 220px;
    max-width: 100%;
    overflow: hidden;
    border-radius: 6px;
  }

  .author__map-widget a {
    margin: 0;
    padding: 0;
    display: inline-block;
  }

  .author__map-widget img {
    display: block;
    width: 100%;
    height: auto;
    border: 1px solid var(--global-border-color);
    border-radius: 6px;
    background: #fff;
  }

  .inline-org-logo {
    display: inline-block;
    height: 1.15em;
    width: auto;
    margin-right: 0.4rem;
    vertical-align: -0.14em;
    object-fit: contain;
  }

  .greedy-nav a {
    position: relative;
    transition: color 180ms ease, opacity 180ms ease;
  }

  .greedy-nav .visible-links > li:not(#theme-toggle) > a,
  .greedy-nav .hidden-links a {
    color: var(--nav-link-text-color);
  }

  .greedy-nav .visible-links > li:not(#theme-toggle) > a:hover,
  .greedy-nav .visible-links > li:not(#theme-toggle) > a:focus-visible,
  .greedy-nav .visible-links > li:not(#theme-toggle) > a.nav-section-active,
  .greedy-nav .hidden-links a:hover,
  .greedy-nav .hidden-links a:focus-visible {
    color: var(--nav-link-hover-color);
  }

  .masthead__menu-item.selected a,
  .masthead__menu-item.selected a:hover {
    color: var(--nav-link-active-color);
    border-bottom-color: var(--nav-link-active-color);
  }

  .greedy-nav .visible-links {
    position: relative;
    padding-right: 3rem;
  }

  .greedy-nav button:not(.hidden) + .visible-links {
    padding-right: 5.6rem;
  }

  .greedy-nav .visible-links #theme-toggle {
    position: absolute;
    top: 50%;
    right: 0;
    display: block;
    transform: translateY(-50%);
  }

  .greedy-nav button:not(.hidden) + .visible-links #theme-toggle {
    right: 2.8rem;
  }

  .greedy-nav .visible-links #theme-toggle a {
    margin: 0;
    width: 2rem;
    min-width: 2rem;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }

  @media (min-width: 64em) {
    .greedy-nav button.hidden + .visible-links {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      width: 100%;
      gap: 3rem;
    }

    .greedy-nav button.hidden + .visible-links > li:not(#theme-toggle) a {
      margin-left: 0;
      margin-right: 0;
    }
  }

  .greedy-nav a::after {
    content: "";
    position: absolute;
    left: 0;
    bottom: -0.2rem;
    width: 100%;
    height: 2px;
    background: currentColor;
    opacity: 0.7;
    transform: scaleX(0);
    transform-origin: left center;
    transition: transform 260ms ease;
  }

  .greedy-nav a:hover::after,
  .greedy-nav a:focus-visible::after,
  .greedy-nav a.nav-section-active::after {
    transform: scaleX(1);
  }

  .greedy-nav a.nav-section-active {
    font-weight: 600;
  }

  .page__content .anchor-scroll-highlight {
    animation: anchorSectionPulse 520ms cubic-bezier(0.2, 0.7, 0.2, 1);
  }

  html.js-enhanced .page__content .reveal-on-scroll {
    opacity: 0;
    transform: translateY(16px);
    filter: blur(2px);
    transition:
      opacity 520ms cubic-bezier(0.2, 0.7, 0.2, 1),
      transform 520ms cubic-bezier(0.2, 0.7, 0.2, 1),
      filter 520ms cubic-bezier(0.2, 0.7, 0.2, 1);
    transition-delay: var(--reveal-delay, 0ms);
    will-change: opacity, transform, filter;
  }

  html.js-enhanced .page__content .reveal-on-scroll.is-visible {
    opacity: 1;
    transform: translateY(0);
    filter: blur(0);
  }

  @keyframes anchorSectionPulse {
    0% {
      transform: translateY(10px);
      opacity: 0.45;
    }
    100% {
      transform: translateY(0);
      opacity: 1;
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .greedy-nav a,
    .greedy-nav a::after {
      transition: none;
    }

    .page__content .anchor-scroll-highlight {
      animation: none;
    }

    html.js-enhanced .page__content .reveal-on-scroll,
    html.js-enhanced .page__content .reveal-on-scroll.is-visible {
      opacity: 1;
      transform: none;
      filter: none;
      transition: none;
    }
  }
</style>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    const reducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    const root = document.documentElement;
    const masthead = document.querySelector(".masthead");
    const navLinks = Array.from(document.querySelectorAll('.greedy-nav a[href*="#"]'));
    const navEntry = (performance.getEntriesByType && performance.getEntriesByType("navigation")[0]) || null;
    const isBackForward = navEntry && navEntry.type === "back_forward";

    if ("scrollRestoration" in history) {
      history.scrollRestoration = "manual";
    }

    if (!navLinks.length) return;

    let activeAnimation = null;
    let activeHighlightTimer = null;
    let scrollTicking = false;

    const samePageHashTarget = (link) => {
      try {
        const url = new URL(link.href, window.location.href);
        if (url.origin !== window.location.origin) return null;
        if (url.pathname.replace(/\/+$/, "") !== window.location.pathname.replace(/\/+$/, "")) return null;
        if (!url.hash) return null;
        const id = decodeURIComponent(url.hash.slice(1));
        return id ? document.getElementById(id) : null;
      } catch (_) {
        return null;
      }
    };

    const linkTargets = navLinks
      .map((link) => ({ link, target: samePageHashTarget(link) }))
      .filter((item) => item.target);

    if (!linkTargets.length) return;

    const getOffset = () => {
      const mastheadHeight = masthead ? masthead.getBoundingClientRect().height : 70;
      return Math.round(mastheadHeight + 8);
    };

    const updateOffsetVar = () => {
      root.style.setProperty("--masthead-offset", getOffset() + "px");
    };

    const easeInOutCubic = (t) => (t < 0.5)
      ? 4 * t * t * t
      : 1 - Math.pow(-2 * t + 2, 3) / 2;

    const animateScrollTo = (targetY, duration) => {
      if (activeAnimation) {
        cancelAnimationFrame(activeAnimation);
        activeAnimation = null;
      }

      const startY = window.scrollY;
      const distance = targetY - startY;
      if (Math.abs(distance) < 2 || reducedMotion) {
        window.scrollTo(0, targetY);
        return Promise.resolve();
      }

      return new Promise((resolve) => {
        const startedAt = performance.now();

        const step = (now) => {
          const elapsed = now - startedAt;
          const progress = Math.min(elapsed / duration, 1);
          const eased = easeInOutCubic(progress);
          window.scrollTo(0, Math.round(startY + distance * eased));

          if (progress < 1) {
            activeAnimation = requestAnimationFrame(step);
            return;
          }

          activeAnimation = null;
          resolve();
        };

        activeAnimation = requestAnimationFrame(step);
      });
    };

    const focusSection = (section) => {
      section.classList.remove("anchor-scroll-highlight");
      // Force reflow so repeated clicks retrigger the animation.
      void section.offsetWidth;
      section.classList.add("anchor-scroll-highlight");
      clearTimeout(activeHighlightTimer);
      activeHighlightTimer = window.setTimeout(() => {
        section.classList.remove("anchor-scroll-highlight");
      }, 650);
    };

    const scrollToSection = async (section, updateHash) => {
      const targetY = Math.max(0, section.getBoundingClientRect().top + window.scrollY - getOffset());
      const distance = Math.abs(targetY - window.scrollY);
      const duration = Math.min(950, Math.max(420, distance * 0.75));

      await animateScrollTo(targetY, duration);
      focusSection(section);

      if (updateHash) {
        history.pushState(null, "", "#" + section.id);
      }
      updateActiveNav();
    };

    const updateActiveNav = () => {
      const threshold = getOffset() + 28;
      let current = linkTargets[0];

      for (const item of linkTargets) {
        if (item.target.getBoundingClientRect().top <= threshold) {
          current = item;
        } else {
          break;
        }
      }

      for (const item of linkTargets) {
        item.link.classList.toggle("nav-section-active", item === current);
        if (item === current) {
          item.link.setAttribute("aria-current", "true");
        } else {
          item.link.removeAttribute("aria-current");
        }
      }
    };

    const onScroll = () => {
      if (scrollTicking) return;
      scrollTicking = true;
      requestAnimationFrame(() => {
        updateActiveNav();
        scrollTicking = false;
      });
    };

    for (const { link, target } of linkTargets) {
      link.addEventListener("click", (event) => {
        if (
          event.defaultPrevented ||
          event.button !== 0 ||
          event.metaKey ||
          event.ctrlKey ||
          event.shiftKey ||
          event.altKey
        ) {
          return;
        }

        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
        scrollToSection(target, true);
      });
    }

    updateOffsetVar();
    updateActiveNav();

    window.addEventListener("resize", () => {
      updateOffsetVar();
      updateActiveNav();
    });
    window.addEventListener("scroll", onScroll, { passive: true });

    if (!window.location.hash && !isBackForward) {
      window.requestAnimationFrame(() => {
        window.scrollTo(0, 0);
        updateActiveNav();
      });
    }

    if (window.location.hash) {
      const initialId = decodeURIComponent(window.location.hash.slice(1));
      const initialTarget = initialId ? document.getElementById(initialId) : null;
      if (initialTarget) {
        window.requestAnimationFrame(() => {
          window.scrollTo(0, Math.max(0, initialTarget.getBoundingClientRect().top + window.scrollY - getOffset()));
          updateActiveNav();
        });
      }
    }

    const contentRoot = document.querySelector(".page__content");
    if (!contentRoot || reducedMotion || !("IntersectionObserver" in window)) return;

    const revealCandidates = Array.from(contentRoot.children).filter((el) => {
      if (!(el instanceof HTMLElement)) return false;
      if (!el.offsetParent && el !== document.activeElement) return false;
      const tag = el.tagName;
      return !["SCRIPT", "STYLE"].includes(tag);
    });

    let sectionOrder = -1;
    let itemOrder = 0;

    for (const el of revealCandidates) {
      const tag = el.tagName;
      const startsSection = /^H[1-3]$/.test(tag);

      if (startsSection) {
        sectionOrder += 1;
        itemOrder = 0;
      }

      if (sectionOrder < 0) {
        sectionOrder = 0;
      }

      const delayMs = Math.min(220, itemOrder * 45);
      el.classList.add("reveal-on-scroll");
      el.style.setProperty("--reveal-delay", delayMs + "ms");
      el.dataset.revealSection = String(sectionOrder);
      itemOrder += 1;
    }

    const revealObserver = new IntersectionObserver((entries, observer) => {
      for (const entry of entries) {
        if (!entry.isIntersecting) continue;
        entry.target.classList.add("is-visible");
        observer.unobserve(entry.target);
      }
    }, {
      root: null,
      rootMargin: "0px 0px -10% 0px",
      threshold: 0.08,
    });

    const viewportBottom = window.scrollY + window.innerHeight;
    for (const el of revealCandidates) {
      const top = el.getBoundingClientRect().top + window.scrollY;
      if (top < viewportBottom - 48) {
        el.classList.add("is-visible");
      } else {
        revealObserver.observe(el);
      }
    }
  });
</script>

<!-- favicon from https://commons.wikimedia.org/wiki/File:OOjs_UI_icon_academic-progressive.svg -->
<link rel="apple-touch-icon" sizes="180x180" href="{{ base_path }}/images/apple-touch-icon-180x180.png"/>
<link rel="icon" type="image/svg+xml" href="{{ base_path }}/images/favicon.svg"/>
<link rel="icon" type="image/png" href="{{ base_path }}/images/favicon-32x32.png" sizes="32x32"/>
<link rel="icon" type="image/png" href="{{ base_path }}/images/favicon-192x192.png" sizes="192x192"/>
<link rel="manifest" href="{{ base_path }}/images/manifest.json"/>
<link rel="icon" href="/images/favicon.ico"/>
<meta name="theme-color" content="#ffffff"/>

<!-- end custom head snippets -->
